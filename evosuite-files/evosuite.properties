CP=follow.jar
PROJECT_PREFIX=
#--------------------------------------
# Test Seeding
#--------------------------------------

# The classpath needed to compile the seeding test case.
#classpath=

# The path to the test case source.
#sourcepath=

#--------------------------------------
# Debugging
#--------------------------------------

# Port on localhost, to which the client VM will listen for a remote debugger; defaults to 1044
#port=1044

# Enables debugging support in the client VM
#debug=false

#--------------------------------------
# Test Execution
#--------------------------------------

# Maximum number of mutants to target at the same time
#max_mutants=100

# Replace nondeterministic calls and System.exit
#replace_calls=false

# Hard limit on array allocation in the code
#array_limit=1000000

# Number of timeouts before we consider a mutant killed
#mutation_timeouts=3

# Replace System.in with a smart stub/mock
#replace_system_in=true

# Milliseconds allowed per test during concolic execution
#concolic_timeout=15000

# Milliseconds grace time to shut down test cleanly
#shutdown_timeout=1000

# Milliseconds allowed per test
#timeout=5000

# Number of generations before changing the currently targeted mutants
#mutation_generations=10

#--------------------------------------
# TestCreation
#--------------------------------------

# Change default package rights to public package rights (?)
#make_accessible=false

#--------------------------------------
# EXSYST
#--------------------------------------

# How often to write out coverage information in the background (in ms). -1 to disable.
#UI_BACKGROUND_COVERAGE_DELAY=-1

#--------------------------------------
# Experimental
#--------------------------------------

# Number of mutations applied to a cloned individual
#seed_mutations=2

# Measure timeouts on CPU time, not global time
#cpu_timeout=false

# Include methods that update required static fields
#handle_static_fields=false

# Check contracts during test execution
#check_contracts=false

# List of fully qualified class names (separated by ':') indicating which JUnit test suites the user has selected (e.g., for seeding)
#selected_junit=null

# Require statement coverage for branch coverage
#branch_statement=false

# The maximum level of recursion when calculating the dependencies in the test cluster
#cluster_recursion=10

# 
#randomize_difficulty=true

# Testability transformation
#tt_scope=ALL

# Check asserts in the SUT
#enable_asserts_for_sut=true

# Probability with which existing individuals are cloned
#seed_clone=0.2

# Testability transformation
#TT=false

# Produce output each time a test times out
#log_timeout=false

# Apply testability transformation (Yanchuan)
#testability_transformation=false

# Check contracts only once per test
#check_contracts_end=false

# Include remote calls
#remote_testing=false

# Check JUnit theories as contracts
#junit_theories=

# When running EvoSuite clients, for debugging purposes check its assserts
#enable_asserts_for_evosuite=false

# 
#enable_alternative_suite_fitness=false

# 
#defuse_aliases=true

# Names of usage model files
#usage_models=

# Also instrument methods called from the SUT
#instrument_context=false

# 
#defuse_debug_mode=false

# Probability of using concolic mutation operator
#concolic_mutation=0.0

# 
#starve_by_fitness=true

# Jeremy's branch evaluation
#branch_eval=false

# Probability to reuse an existing test case, if it produces a required object
#call_probability=0.0

# Probability with which to use transitions out of the OUM
#usage_rate=0.5

# Skip debug information in bytecode instrumentation (needed for compatibility with classes transformed by Emma code instrumentation due to an ASM bug)
#instrumentation_skip_debug=false

# 
#alternative_fitness_calculation_mode=SUM

# Instrument code with error checking branches
#error_branches=false

# Cached version of inheritance tree
inheritance_file=evosuite-files/inheritance.xml.gz

# Number of attempts to solve constraints related to one code branch
#constraint_solution_attempts=3

# Stop test execution if exception occurrs
#break_on_exception=true

# Maximum stack depth for testability transformation
#TT_stack=10

# Prefix of JUnit tests to execute
#junit_prefix=

# 
#enable_alternative_fitness_calculation=false

# Which factory creates tests
#test_factory=RANDOM

# Only include test files containing the target classname
#junit_strict=false

# Also count coverage goals in superclasses
#instrument_parent=false

#--------------------------------------
# Single Branch Mode
#--------------------------------------

# Seed initial population with related individuals (Single branch mode)
#recycle_chromosomes=true

# Use leftover budget on unsatisfied test goals (Single branch mode)
#reuse_budget=true

# Number of random tests to run before test generation (Single branch mode)
#random_tests=0

# Shuffle test goals before test generation (Single branch mode)
#shuffle_goals=true

# Skip coverage goals that have already been (coincidentally) covered
#skip_covered=true

#--------------------------------------
# Output
#--------------------------------------

# Create a CSV file for each individual evolution
#log_goals=false

# Create plots of size and fitness
#plot=false

# Verbosity level of logger
#log.level=null

# Serialize result of search to main process
#serialize_result=false

# Use the old statistics backend on the master
#old_statistics=true

# Store test suite on Ctrl+C
#shutdown_hook=true

# Label that specifies a group the SUT belongs to. This is only needed for running experiments.
#group_id=none

# Create assertions
#assertions=true

# Print out covered goals during test generation
#print_covered_goals=false

# Maximum depth in the calltree to count a branch as covered
#max_coverage_depth=-1

# Keep sequences for object pool
#write_pool=

# Label that identifies the used configuration of EvoSuite. This is only done when running experiments.
#configuration_id=null

# Location of where to locate tools.jar
#tools_jar_location=null

# Use EvoSuite JUnit runner in generated test suites
#junit_runner=false

# List of variables to output to CSV file. Variables are separated by commas. Null represents default values
#output_variables=null

# Time interval in milliseconds for timeline statistics
#timeline_interval=60000

# Generate and store all data reports
#save_all_data=true

# Target logger - all logging if not set
#log.target=null

# Create CFG graphs
#write_cfg=false

# How many replacement mutants can be inserted for any one variable
#max_replace_mutants=100

# Suffix that is appended at each generated JUnit file name
#junit_suffix=EvoSuiteTest

# Allow test output on console
#print_to_system=false

# Create JUnit test suites
#junit_tests=true

# Filter flaky assertions
#filter_assertions=false

# Print out current goal during test generation
#print_current_goals=false

# How many mutants can be inserted into a single method
#max_mutants_per_method=700

# Include the GA instance in the test generation result
#serialize_ga=false

# Show progress bar on console
#show_progress=true

# Create html reports
#html=true

# Use the new statistics backend on the master
#new_statistics=false

# Minimize test suite after generation
#minimize=true

# How many mutants to use when trying to find assertions for a test
#max_mutants_per_test=100

# Format of the resulting test cases
#test_format=JUNIT4

# Directory in which to put HTML and CSV reports
#report_dir=evosuite-report

# Which assertions to generate
#assertion_strategy=MUTATION

# Compile and run resulting JUnit test suite
#junit_check=true

# Directory in which to place JUnit tests
#test_dir=evosuite-tests

# List of criteria which should be measured on the completed test suite
#analysis_criteria=

# Extend existing JUnit test suite
#junit_extend=

# Include a header with coverage information for each test
#test_comments=true

# Which backend to use to collect data
#statistics_backend=CSV

# Minimize test suite using old algorithm
#minimize_old=false

# Minimize constants and method calls
#minimize_values=false

# Write all test cases for a class into a single file or to separate files.
#output_granularity=MERGED

# Minimize test suite after generation
#coverage=true

# Inline all constants
#inline=false

#--------------------------------------
# Test Creation
#--------------------------------------

# File containing methods that should not be used in testing
#test_excludes=test.excludes

# Probability to use a predefined sequence from the pool rather than a random generator
#p_object_pool=0.3

# Include deprecated methods in tests
#use_deprecated=false

# Probability to replace a primitive with a random new value rather than adding a delta
#random_perturbation=0.2

# Score for selection of insertion call with existing object
#insertion_score_parameter=1

# Number of attempts when generating an object before giving up
#max_attempts=1000

# Probability to use null instead of constructing an object
#null_probability=0.1

# Replace string.equals with levenshtein distance
#string_replacement=true

# Probability to use a primitive from the pool rather than a random value
#primitive_pool=0.5

# Prohibit integers in the pool greater than max_int
#restrict_pool=false

# Number of random tests
#num_random_tests=20

# Probability to use a primitive from the dynamic pool rather than a random value
#dynamic_pool=0.5

# Use type information gathered from casts to instantiate generics
#seed_types=true

# If set to true EvoSuite test generation inits UISpec in order to avoid display of UI
#evosuite_use_uispec=false

# Recursion depth when trying to create objects
#max_recursion=10

# Score for selection of insertion of call on existing object
#insertion_score_object=1

# Call static constructors only after each a static field was modified
#reset_static_fields=false

# List of object pools
#object_pools=

# Epsilon for floats in local search
#epsilon=0.001

# Maximum level of nesting for generic types
#max_generic_depth=2

# If a carved test throws an exception, either chop it off, or drop it
#chop_carved_exceptions=true

# Score for selection of insertion of UUT calls
#insertion_score_uut=1

# Probability of using a non-standard call on a special case (collection/numeric)
#p_special_type_call=0.05

# Maximum length of randomly generated arrays
#max_array=10

# Maximum length of test suites (0 = no check)
#max_length=0

# Probability to reuse an existing primitive, if available
#primitive_reuse_probability=0.5

# Number of tests in initial test suites
#num_tests=2

# Maximum length of randomly generated strings
#string_length=20

# Probability to reuse an existing reference, if available
#object_reuse_probability=0.9

# Number of dynamic constants to keep
#dynamic_pool_size=50

# Maximum size of randomly generated integers (minimum range = -1 * max)
#max_int=2048

# Enable test carving
#test_carving=false

# Maximum number of test cases in a test suite
#max_size=100

# File containing methods that should be included in testing
#test_includes=test.includes

# Minimum number of tests in initial test suites
#min_initial_tests=1

# Generate unit tests for 'main(String[] args)' methods as well
#consider_main_methods=false

# Maximum number of tests in initial test suites
#max_initial_tests=10

# Maximum size of delta for numbers during mutation
#max_delta=20

#--------------------------------------
# Continuous Test Generation
#--------------------------------------

# How many minutes to allocate for each class. If this parameter is set, then ctg_time is going to be ignored. This parameter is mainly meant for debugging purposes.
#ctg_time_per_class=null

# Where generated files will be stored
#ctg_folder=.continuous_evosuite

# Schedule used to run jobs
#ctg_schedule=SIMPLE

# Total Memory (in MB) that CTG will use
#ctg_memory=1000

# How many minutes each class under test should have at least
#ctg_min_time_per_job=1

# How many minutes in total CTG will run
#ctg_time=1

# Number of cores CTG will use
#ctg_cores=1

#--------------------------------------
# Search Algorithm
#--------------------------------------

# Selection function during search
#selection_function=RANK

# Seconds allowed for minimization at the end
#minimization_timeout=600

# Maximum attempts at improving individuals per local search
#local_search_budget=100

# Extra seconds allowed for the search
#extra_timeout=120

# Apply local search only to individuals that changed fitness
#local_search_selective=false

# Initial probability of inserting a new test in a test suite
#p_test_insertion=0.1

# Multiply search budget by number of test goals
#dynamic_limit=false

# Seed used for random generator. If left empty, use current time
#random_seed=null

# Stop optimization once goal is covered
#stop_zero=true

# Probability of inserting new statements during mutation
#p_test_insert=0.3333333333333333

# Population size of genetic algorithm
#population=50

# Probability of deleting statements during mutation
#p_test_delete=0.3333333333333333

# Add tests that cover branches already covered in the past
#local_search_restore_coverage=true

# Apply local search at every X generation
#local_search_rate=-1

# Check length against length of parents
#check_parents_length=false

# Granularity of DSE application
#local_search_dse=OFF

# Only check primitives for selective LS
#local_search_selective_primitives=false

# Rank branch conditions
#dse_rank_branch_conditions=true

# Search algorithm
#algorithm=STEADYSTATEGA

# Secondary objective during search
#secondary_objectives=totallength

# Initial probability of inserting a new statement in a test case
#p_statement_insertion=0.5

# What condition should be checked to end the search
#stopping_condition=MAXTIME

# Times DSE resets the int and real variables with random values
#dse_variable_resets=2

# Seconds allowed for assertion generation at the end
#assertion_timeout=600

# If a branch is only executed once by a test suite, duplicate that test
#local_search_ensure_double_execution=true

# What to use as limit for the population size
#population_limit=INDIVIDUALS

# Maximum number of solving time for Constraint solver in milliseconds
#dse_constraint_solver_timeout_millis=1000

# Seconds allowed for carving JUnit tests
#carving_timeout=600

# Keep tests even if they do not increase fitness
#dse_keep_all_tests=false

# Check against parents in Mu+Lambda algorithm
#parent_check=true

# Elite size for search algorithm
#elite=1

# Maximum relative increase in length
#bloat_factor=2

# Maximum length of chromosomes during search
#chromosome_length=40

# Maximum search duration
#search_budget=60

# Seconds allowed for initializing the search
#initialization_timeout=600

# Negate all branch conditions in the path condition (covered or not)
#dse_negate_all_conditions=true

# Probability of crossover
#crossover_rate=0.75

# Penalty for duplicate individuals
#kincompensation=1.0

# Probability with which to use constants from the constraints when resetting variables during search
#dse_constant_probability=0.5

# Crossover function during search
#crossover_function=SINGLEPOINTRELATIVE

# Apply local search at every X generation
#local_search_adaptation_rate=1.0

# Perform local search on array statements
#local_search_arrays=true

# Check length against length of best individual
#check_best_length=true

# Perform local search on primitive values
#local_search_strings=true

# Number of single mutations applied on an individual when a mutation event occurs
#number_of_mutations=1

# Check length against fixed maximum
#check_max_length=true

# Initial probability of inserting a new statement in a test case
#p_change_parameter=0.1

# Replacement function for comparing offspring to parents during search
#replacement_function=DEFAULT

# Perform local search on primitive values
#local_search_primitives=true

# Number of individuals for tournament selection
#tournament_size=10

# Expand test cases before applying local search such that each primitive is used only once
#local_search_expand_tests=true

# Bias for better individuals in rank selection
#rank_bias=1.7

# Maximal length of the constraints in DSE
#dse_constraint_length=100000

# Interpretation of local_search_budget
#local_search_budget_type=STATEMENTS

# How many mutations to apply to a string to check whether it improves coverage
#local_search_probes=10

# Perform local search on reference types
#local_search_references=true

# Apply local search at every X generation
#local_search_probability=1.0

# Maximum seconds allowed for entire search when not using time as stopping criterion
#global_timeout=600

# Probability of changing statements during mutation
#p_test_change=0.3333333333333333

#--------------------------------------
# Sandbox
#--------------------------------------

# Usa a virtual file system for all File I/O operations
#virtual_fs=false

# Drop tests that require the sandbox
#filter_sandbox_tests=false

# Mode in which the sandbox is applied
#sandbox_mode=RECOMMENDED

# Execute tests in a sandbox environment
#sandbox=true

